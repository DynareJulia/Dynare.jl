<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal policy · Dynare.jl</title><meta name="title" content="Optimal policy · Dynare.jl"/><meta property="og:title" content="Optimal policy · Dynare.jl"/><meta property="twitter:title" content="Optimal policy · Dynare.jl"/><meta name="description" content="Documentation for Dynare.jl."/><meta property="og:description" content="Documentation for Dynare.jl."/><meta property="twitter:description" content="Documentation for Dynare.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dynare.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation-and-configuration/">Installation and Configuration</a></li><li><a class="tocitem" href="../../running-dynare/">Running Dynare</a></li><li><span class="tocitem">Model File</span><ul><li><a class="tocitem" href="../syntax-elements/">Syntax elements</a></li><li><a class="tocitem" href="../variable-declarations/">Variables and parameters declaration</a></li><li><a class="tocitem" href="../model-declaration/">Model declaration</a></li><li><a class="tocitem" href="../steady-state/">Steady state</a></li><li><a class="tocitem" href="../shocks/">Shocks on exgogenous variables</a></li><li><a class="tocitem" href="../deterministic-simulations/">Deterministic simulations</a></li><li><a class="tocitem" href="../local-approxiation/">Local approximation</a></li><li><a class="tocitem" href="../filtersmoother/">State space, filtering and smoothing</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecasting/">Forecasting</a></li><li class="is-active"><a class="tocitem" href>Optimal policy</a><ul class="internal"><li><a class="tocitem" href="#Forecasting"><span>Forecasting</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../macroprocessor/">Macroprocessing language</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model File</a></li><li class="is-active"><a href>Optimal policy</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal policy</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl/blob/main/docs/src/model-file/optimal-policy.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Forecasting"><a class="docs-heading-anchor" href="#Forecasting">Forecasting</a><a id="Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting" title="Permalink"></a></h2><p>On a calibrated model, forecasting is done using the <code>forecast</code> command. On an estimated model, use the <code>forecast</code> option of <code>estimation</code> command.</p><p>It is also possible to compute forecasts on a calibrated or estimated model for a given constrained path of the future endogenous variables. This is done, from the reduced form representation of the DSGE model, by finding the structural shocks that are needed to match the restricted paths. Use <code>conditional_forecast</code>{.interpreted-text role=&quot;comm&quot;}, <code>conditional_forecast_paths</code>{.interpreted-text role=&quot;bck&quot;} and <code>plot_conditional_forecast</code>{.interpreted-text role=&quot;comm&quot;} for that purpose.</p><p>Finally, it is possible to do forecasting with a Bayesian VAR using the <code>bvar_forecast</code>{.interpreted-text role=&quot;comm&quot;} command.</p><p><em>Command</em>: <code>forecast [VARIABLE_NAME...];</code></p><p><em>Command</em>: <code>forecast (OPTIONS...)[VARIABLE_NAME...];</code></p><p>This command computes a simulation of a stochastic model from an arbitrary initial point.</p><p>When the model also contains deterministic exogenous shocks, the simulation is computed conditionally to the agents knowing the future values of the deterministic exogenous variables.</p><p><code>forecast</code> must be called after <code>stoch_simul</code>.</p><p><code>forecast</code> plots the trajectory of endogenous variables. When a list of variable names follows the command, only those variables are plotted. A 90% confidence interval is plotted around the mean trajectory. Use option <code>conf_sig</code> to change the level of the confidence interval.</p><p><em>Options</em></p><ul><li><code>periods = INTEGER</code></li></ul><p>Number of periods of the forecast. Default: <code>5</code>.</p><ul><li><code>conf_sig = DOUBLE</code></li></ul><p>Level of significance for confidence interval. Default: <code>0.90</code>.</p><ul><li><code>nograph</code></li></ul><p>See <code>nograph</code>{.interpreted-text role=&quot;opt&quot;}.</p><ul><li><code>nodisplay</code></li></ul><p>See <code>nodisplay</code>{.interpreted-text role=&quot;opt&quot;}.</p><ul><li><code>graph_format = FORMAT graph_format = ( FORMAT, FORMAT... )</code></li></ul><p>See <code>graph_format = FORMAT</code>{.interpreted-text role=&quot;opt&quot;}.</p><p><em>Initial Values</em></p><p><code>forecast</code> computes the forecast taking as initial values the values specified in <code>histval</code> (see <code>histval</code>{.interpreted-text role=&quot;bck&quot;}). When no <code>histval</code> block is present, the initial values are the one stated in <code>initval</code>. When <code>initval</code> is followed by command <code>steady</code>, the initial values are the steady state (see <code>steady</code>{.interpreted-text role=&quot;comm&quot;}).</p><p><em>Output</em></p><p>The results are stored in <code>oo_.forecast</code>, which is described below.</p><p><em>Example</em></p><pre><code class="nohighlight hljs">     varexo_det tau;

     varexo e;
     ...
     shocks;
     var e; stderr 0.01;
     var tau;
     periods 1:9;
     values -0.15;
     end;

     stoch_simul(irf=0);

     forecast;</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.forecast</code></p><p>Variable set by the <code>forecast</code> command, or by the <code>estimation</code> command if used with the <code>forecast</code> option and ML or if no Metropolis-Hastings has been computed (in that case, the forecast is computed for the posterior mode). Fields are of the form:</p><pre><code class="nohighlight hljs">    oo_.forecast.FORECAST_MOMENT.VARIABLE_NAME</code></pre><p>where <code>FORECAST_MOMENT</code> is one of the following:</p><pre><code class="nohighlight hljs">`HPDinf`

Lower bound of a 90% HPD interval[^10] of forecast due to parameter
uncertainty, but ignoring the effect of measurement error on
observed variables. In case of ML, it stores the lower bound of the
confidence interval.

`HPDsup`

Upper bound of a 90% HPD forecast interval due to parameter
uncertainty, but ignoring the effect of measurement error on
observed variables. In case of ML, it stores the upper bound of the
confidence interval.</code></pre><p><code>HPDinf_ME</code></p><pre><code class="nohighlight hljs">Lower bound of a 90% HPD interval[^11] of forecast for observed
variables due to parameter uncertainty and measurement error. In
case of ML, it stores the lower bound of the confidence interval.

`HPDsup_ME`

Upper bound of a 90% HPD interval of forecast for observed variables
due to parameter uncertainty and measurement error. In case of ML,
it stores the upper bound of the confidence interval.

`Mean`

Mean of the posterior distribution of forecasts.</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.PointForecast</code></p><p>Set by the <code>estimation</code> command, if it is used with the <code>forecast</code> option and if either <code>mh_replic &gt; 0</code> or the <code>load_mh_file</code> option are used.</p><p>Contains the distribution of forecasts taking into account the uncertainty about both parameters and shocks.</p><p>Fields are of the form:</p><pre><code class="nohighlight hljs">    oo_.PointForecast.MOMENT_NAME.VARIABLE_NAME</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.MeanForecast</code></p><p>Set by the <code>estimation</code> command, if it is used with the <code>forecast</code> option and if either <code>mh_replic &gt; 0</code> or <code>load_mh_file</code> option are used.</p><p>Contains the distribution of forecasts where the uncertainty about shocks is averaged out. The distribution of forecasts therefore only represents the uncertainty about parameters.</p><p>Fields are of the form:</p><pre><code class="nohighlight hljs">    oo_.MeanForecast.MOMENT_NAME.VARIABLE_NAME</code></pre><p><em>Command</em>: <code>conditional_forecast (OPTIONS...);</code></p><p>This command computes forecasts on an estimated or calibrated model for a given constrained path of some future endogenous variables. This is done using the reduced form first order state-space representation of the DSGE model by finding the structural shocks that are needed to match the restricted paths. Consider the augmented state space representation that stacks both predetermined and non-predetermined variables into a vector <span>$y_{t}$</span>:</p><p class="math-container">\[y_t=Ty_{t-1}+R\varepsilon_t\]</p><p>Both <span>$y_t$</span> and <span>$\varepsilon_t$</span> are split up into controlled and uncontrolled ones, and we assume without loss of generality that the constrained endogenous variables and the controlled shocks come first :</p><p class="math-container">\[\begin{aligned}
\begin{pmatrix}
 y_{c,t}\\
 y_{u,t}
 \end{pmatrix}
 =
 \begin{pmatrix}
 T_{c,c} &amp; T_{c,u}\\
 T_{u,c} &amp; T_{u,u}
 \end{pmatrix}
 \begin{pmatrix}
 y_{c,t-1}\\
 y_{u,t-1}
 \end{pmatrix}
 +
 \begin{pmatrix}
 R_{c,c} &amp; R_{c,u}\\
 R_{u,c} &amp; R_{u,u}
 \end{pmatrix}
 \begin{pmatrix}
 \varepsilon_{c,t}\\
 \varepsilon_{u,t}
 \end{pmatrix}
 \end{aligned}\]</p><p>where matrices <span>$T$</span> and <span>$R$</span> are partitioned consistently with the vectors of endogenous variables and innovations. Provided that matrix <span>$R_{c,c}$</span> is square and full rank (a necessary condition is that the number of free endogenous variables matches the number of free innovations), given <span>$y_{c,t}$</span>, <span>$\varepsilon_{u,t}$</span> and <span>$y_{t-1}$</span> the first block of equations can be solved for <span>$\varepsilon_{c,t}$</span>:</p><p class="math-container">\[\varepsilon_{c,t} = R_{c,c}^{-1}\bigl( y_{c,t} - T_{c,c}y_{c,t} - T_{c,u}y_{u,t}  - R_{c,u}\varepsilon_{u,t}\bigr)\]</p><p>and <span>$y_{u,t}$</span> can be updated by evaluating the second block of equations:</p><p class="math-container">\[y_{u,t} = T_{u,c}y_{c,t-1} + T_{u,u}y_{u,t-1} +  R_{u,c}\varepsilon_{c,t} + R_{u,u}\varepsilon_{u,t}\]</p><p>By iterating over these two blocks of equations, we can build a forecast for all the endogenous variables in the system conditional on paths for a subset of the endogenous variables. If the distribution of the free innovations <span>$\varepsilon_{u,t}$</span> is provided (<em>i.e.</em> some of them have positive variances) this exercise is replicated (the number of replication is controlled by the option <code>replic</code>{.interpreted-text role=&quot;opt&quot;} described below) by drawing different sequences of free innovations. The result is a predictive distribution for the uncontrolled endogenous variables, <span>$y_{u,t}$</span>, that Dynare will use to report confidence bands around the point conditional forecast.</p><p>A few things need to be noted. First, the controlled exogenous variables are set to zero for the uncontrolled periods. This implies that there is no forecast uncertainty arising from these exogenous variables in uncontrolled periods. Second, by making use of the first order state space solution, even if a higher-order approximation was performed, the conditional forecasts will be based on a first order approximation. Since the controlled exogenous variables are identified on the basis of the reduced form model (<em>i.e.</em> after solving for the expectations), they are unforeseen shocks from the perspective of the agents in the model. That is, agents expect the endogenous variables to return to their respective steady state levels but are surprised in each period by the realisation of shocks keeping the endogenous variables along a predefined (unexpected) path. Fourth, if the structural innovations are correlated, because the calibrated or estimated covariance matrix has non zero off diagonal elements, the results of the conditional forecasts will depend on the ordering of the innovations (as declared after <code>varexo</code>). As in VAR models, a Cholesky decomposition is used to factorise the covariance matrix and identify orthogonal impulses. It is preferable to declare the correlations in the model block (explicitly imposing the identification restrictions), unless you are satisfied with the implicit identification restrictions implied by the Cholesky decomposition.</p><p>This command has to be called after <code>estimation</code> or <code>stoch_simul</code>.</p><p>Use <code>conditional_forecast_paths</code>{.interpreted-text role=&quot;bck&quot;} block to give the list of constrained endogenous, and their constrained future path. Option <code>controlled_varexo</code> is used to specify the structural shocks which will be matched to generate the constrained path.</p><p>Use <code>plot_conditional_forecast</code>{.interpreted-text role=&quot;comm&quot;} to graph the results.</p><p><em>Options</em></p><ul><li><code>parameter_set = OPTION</code></li></ul><p>See <code>parameter_set &lt;parameter_set = OPTION&gt;</code>{.interpreted-text role=&quot;opt&quot;} for possible values. No default value, mandatory option.</p><ul><li><code>controlled_varexo = (VARIABLE_NAME...)</code></li></ul><p>Specify the exogenous variables to use as control variables. No default value, mandatory option.</p><ul><li><code>periods = INTEGER</code></li></ul><p>Number of periods of the forecast. Default: <code>40</code>. <code>periods</code> cannot be smaller than the number of constrained periods.</p><ul><li><code>replic = INTEGER</code></li></ul><p>Number of simulations used to compute the conditional forecast uncertainty. Default: <code>5000</code>.</p><ul><li><code>conf_sig = DOUBLE</code></li></ul><p>Level of significance for confidence interval. Default: <code>0.80</code>.</p><p><em>Output</em></p><p>The results are stored in <code>oo_.conditional_forecast</code>, which is described below.</p><p><em>Example</em></p><pre><code class="nohighlight hljs">     var y a;
     varexo e u;
     ...
     estimation(...);

     conditional_forecast_paths;
     var y;
     periods 1:3, 4:5;
     values 2, 5;
     var a;
     periods 1:5;
     values 3;
     end;

     conditional_forecast(parameter_set = calibration, controlled_varexo = (e, u), replic = 3000);
     plot_conditional_forecast(periods = 10) a y;</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.conditional_forecast.cond</code></p><p>Variable set by the <code>conditional_forecast</code> command. It stores the conditional forecasts. Fields are <code>periods+1</code> by <code>1</code> vectors storing the steady state (time 0) and the subsequent <code>periods</code> forecasts periods. Fields are of the form:</p><pre><code class="nohighlight hljs">    oo_.conditional_forecast.cond.FORECAST_MOMENT.VARIABLE_NAME</code></pre><p>where FORECAST_MOMENT is one of the following:</p><pre><code class="nohighlight hljs">`Mean`

Mean of the conditional forecast distribution.

`ci`

Confidence interval of the conditional forecast distribution. The
size corresponds to `conf_sig`.</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.conditional_forecast.uncond</code></p><p>Variable set by the <code>conditional_forecast</code> command. It stores the unconditional forecasts. Fields are of the form:</p><pre><code class="nohighlight hljs">    oo_.conditional_forecast.uncond.FORECAST_MOMENT.VARIABLE_NAME</code></pre><p><em>MATLAB/Octave Variables</em>: <code>forecasts.instruments</code></p><p>Variable set by the <code>conditional_forecast command</code>. Stores the names of the exogenous instruments.</p><p><em>MATLAB/Octave Variables</em>: <code>oo.conditional_forecast.controlled_variables</code></p><p>Variable set by the <code>conditional_forecast</code> command. Stores the position of the constrained endogenous variables in declaration order.</p><p><em>MATLAB/Octave Variables</em>: <code>oo.conditional_forecast.controlled_exo_variables</code></p><p>Variable set by the <code>conditional_forecast</code> command. Stores the values of the controlled exogenous variables underlying the conditional forecasts to achieve the constrained endogenous variables. Fields are <code>[number of constrained periods]</code> by <code>1</code> vectors and are of the form:</p><pre><code class="nohighlight hljs">    oo_.conditional_forecast.controlled_exo_variables.FORECAST_MOMENT.SHOCK_NAME</code></pre><p><em>MATLAB/Octave Variables</em>: <code>oo.conditional_forecast.graphs</code></p><p>Variable set by the <code>conditional_forecast</code> command. Stores the information for generating the conditional forecast plots.</p><p><em>Block</em>: <code>conditional_forecast_paths ;</code></p><p>Describes the path of constrained endogenous, before calling <code>conditional_forecast</code>. The syntax is similar to deterministic shocks in <code>shocks</code>, see <code>conditional_forecast</code> for an example.</p><p>The syntax of the block is the same as for the deterministic shocks in the <code>shocks</code> blocks (see <code>shocks-exo</code>). Note that you need to specify the full path for all constrained endogenous variables between the first and last specified period. If an intermediate period is not specified, a value of 0 is assumed. That is, if you specify only values for periods 1 and 3, the values for period 2 will be 0. Currently, it is not possible to have uncontrolled intermediate periods.</p><p>It is however possible to have different number of controlled periods for different variables. In that case, the order of declaration of endogenous controlled variables and of <code>controlled_varexo</code> matters: if the second endogenous variable is controlled for less periods than the first one, the second <code>controlled_varexo</code> isn\&#39;t set for the last periods.</p><p>In case of the presence of <code>observation_trends</code>, the specified controlled path for these variables needs to include the trend component. When using the <code>loglinear &lt;logl&gt;</code>{.interpreted-text role=&quot;ref&quot;} option, it is necessary to specify the logarithm of the controlled variables.</p><p><em>Block</em>: <code>filter_initial_state ;</code></p><p>This block specifies the initial values of the endogenous states at the beginning of the Kalman filter recursions. That is, if the Kalman filter recursion starts with time t=1 being the first observation, this block provides the state estimate at time 0 given information at time 0, <span>$E_0(x_0)$</span>. If nothing is specified, the initial condition is assumed to be at the steady state (which is the unconditional mean for a stationary model).</p><p>This block is terminated by <code>end;</code>.</p><p>Each line inside of the block should be of the form:</p><pre><code class="nohighlight hljs">    VARIABLE_NAME(INTEGER)=EXPRESSION;</code></pre><p><code>EXPRESSION</code> is any valid expression returning a numerical value and can contain parameter values. This allows specifying relationships that will be honored during estimation. <code>INTEGER</code> refers to the lag with which a variable appears. By convention in Dynare, period 1 is the first period. Going backwards in time, the first period before the start of the simulation is period 0, then period -1, and so on. Note that the <code>filter_initial_state</code> block does not take non-state variables.</p><p><em>Example</em></p><pre><code class="nohighlight hljs">     filter_initial_state;
     k(0)= ((1/bet-(1-del))/alp)^(1/(alp-1))*l_ss;
     P(0)=2.5258;
     m(0)= mst;
     end;</code></pre><p><em>Command</em>: <code>plot_conditional_forecast [VARIABLE_NAME...];</code></p><p><em>Command</em>: <code>plot_conditional_forecast (periods = INTEGER) [VARIABLE_NAME...];</code></p><p>Plots the conditional (plain lines) and unconditional (dashed lines) forecasts.</p><p>To be used after <code>conditional_forecast</code>.</p><p><em>Options</em></p><ul><li><code>periods = INTEGER</code></li></ul><p>Number of periods to be plotted. Default: equal to periods in <code>conditional_forecast</code>. The number of periods declared in <code>plot_conditional_forecast</code> cannot be greater than the one declared in <code>conditional_forecast</code>.</p><ul><li><code>bvar_forecast ;</code></li></ul><p>This command computes (out-of-sample) forecasts for an estimated BVAR model, using Minnesota priors.</p><p>See <code>bvar-a-la-sims.pdf</code>, which comes with Dynare distribution, for more information on this command.</p><p>If the model contains strong non-linearities or if some perfectly expected shocks are considered, the forecasts and the conditional forecasts can be computed using an extended path method. The forecast scenario describing the shocks and/or the constrained paths on some endogenous variables should be build. The first step is the forecast scenario initialization using the function <code>init_plan</code>:</p><ul><li><code>HANDLE = init_plan (DATES);</code></li></ul><p>Creates a new forecast scenario for a forecast period (indicated as a dates class, see <code>dates class members &lt;dates-members&gt;</code>). This function return a handle on the new forecast scenario.</p><p>The forecast scenario can contain some simple shocks on the exogenous variables. This shocks are described using the function <code>basic_plan</code>:</p><p><em>MATLAB/Octave Command</em>: </p><pre><code class="nohighlight hljs">HANDLE = basic_plan (HANDLE, `VAR_NAME&#39;, `SHOCK_TYPE&#39;, DATES, MATLAB VECTOR OF DOUBLE | [DOUBLE | EXPR [DOUBLE | EXPR] ] );</code></pre><p>Adds to the forecast scenario a shock on the exogenous variable indicated between quotes in the second argument. The shock type has to be specified in the third argument between quotes: &#39;surprise&#39; in case of an unexpected shock or &#39;perfect_foresight&#39; for a perfectly anticipated shock. The fourth argument indicates the period of the shock using a dates class (see <code>dates class members &lt;dates-members&gt;</code>). The last argument is the shock path indicated as a MATLAB vector of double. This function return the handle of the updated forecast scenario.</p><p>The forecast scenario can also contain a constrained path on an endogenous variable. The values of the related exogenous variable compatible with the constrained path are in this case computed. In other words, a conditional forecast is performed. This kind of shock is described with the function <code>flip_plan</code>:</p><p><em>MATLAB/Octave Command</em>: </p><pre><code class="nohighlight hljs">HANDLE = flip_plan (HANDLE, `VAR_NAME&#39;, `VAR_NAME&#39;, `SHOCK_TYPE&#39;, DATES, MATLAB VECTOR OF DOUBLE | [DOUBLE | EXPR [DOUBLE | EXPR] ] );</code></pre><p>Adds to the forecast scenario a constrained path on the endogenous variable specified between quotes in the second argument. The associated exogenous variable provided in the third argument between quotes, is considered as an endogenous variable and its values compatible with the constrained path on the endogenous variable will be computed. The nature of the expectation on the constrained path has to be specified in the fourth argument between quotes: &#39;surprise&#39; in case of an unexpected path or &#39;perfect_foresight&#39; for a perfectly anticipated path. The fifth argument indicates the period where the path of the endogenous variable is constrained using a dates class (see <code>dates class members &lt;dates-members&gt;</code>). The last argument contains the constrained path as a MATLAB vector of double. This function return the handle of the updated forecast scenario.</p><p>Once the forecast scenario if fully described, the forecast is computed with the command <code>det_cond_forecast</code>:</p><p><em>MATLAB/Octave Command</em>:</p><pre><code class="nohighlight hljs">DSERIES = det_cond_forecast (HANDLE[, DSERIES [, DATES]]);</code></pre><p>Computes the forecast or the conditional forecast using an extended path method for the given forecast scenario (first argument). The past values of the endogenous and exogenous variables provided with a dseries class (see <code>dseries class members &lt;dseries-members&gt;</code>) can be indicated in the second argument. By default, the past values of the variables are equal to their steady-state values. The initial date of the forecast can be provided in the third argument. By default, the forecast will start at the first date indicated in the <code>init_plan command</code>. This function returns a dset containing the historical and forecast values for the endogenous and exogenous variables.</p><p><em>Example</em></p><pre><code class="nohighlight hljs">     % conditional forecast using extended path method
     % with perfect foresight on r path

     var y r;
     varexo e u;
     ...
     smoothed = dseries(&#39;smoothed_variables.csv&#39;);

     fplan = init_plan(2013Q4:2029Q4);
     fplan = flip_plan(fplan, &#39;y&#39;, &#39;u&#39;, &#39;surprise&#39;, 2013Q4:2014Q4,  [1 1.1 1.2 1.1 ]);
     fplan = flip_plan(fplan, &#39;r&#39;, &#39;e&#39;, &#39;perfect_foresight&#39;, 2013Q4:2014Q4,  [2 1.9 1.9 1.9 ]);

     dset_forecast = det_cond_forecast(fplan, smoothed);

     plot(dset_forecast.{&#39;y&#39;,&#39;u&#39;});
     plot(dset_forecast.{&#39;r&#39;,&#39;e&#39;});</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../forecasting/">« Forecasting</a><a class="docs-footer-nextpage" href="../../macroprocessor/">Macroprocessing language »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 21 December 2023 17:27">Thursday 21 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
