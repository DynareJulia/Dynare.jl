<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deterministic simulations · Dynare.jl</title><meta name="title" content="Deterministic simulations · Dynare.jl"/><meta property="og:title" content="Deterministic simulations · Dynare.jl"/><meta property="twitter:title" content="Deterministic simulations · Dynare.jl"/><meta name="description" content="Documentation for Dynare.jl."/><meta property="og:description" content="Documentation for Dynare.jl."/><meta property="twitter:description" content="Documentation for Dynare.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dynare.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation-and-configuration/">Installation and Configuration</a></li><li><a class="tocitem" href="../../running-dynare/">Running Dynare</a></li><li><span class="tocitem">Model File</span><ul><li><a class="tocitem" href="../syntax-elements/">Syntax elements</a></li><li><a class="tocitem" href="../variable-declarations/">Variables and parameters declaration</a></li><li><a class="tocitem" href="../model-declaration/">Model declaration</a></li><li><a class="tocitem" href="../steady-state/">Steady state</a></li><li><a class="tocitem" href="../shocks/">Shocks on exgogenous variables</a></li><li class="is-active"><a class="tocitem" href>Deterministic simulations</a></li><li><a class="tocitem" href="../local-approxiation/">Local approximation</a></li><li><a class="tocitem" href="../filtersmoother/">State space, filtering and smoothing</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecasting/">Forecasting</a></li></ul></li><li><a class="tocitem" href="../../macroprocessor/">Macroprocessing language</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model File</a></li><li class="is-active"><a href>Deterministic simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Deterministic simulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl/blob/main/docs/src/model-file/deterministic-simulations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>When the framework is deterministic, Dynare can be used for models with the assumption of perfect foresight. The system is supposed to be in a given state before a period <code>1</code> (often a steady state)  when the news of a contemporaneous or of a future shock is learned by the agents in the model. The purpose of the simulation is to describe the reaction in anticipation of, then in reaction to the shock, until the system returns to equilibrium. This return to equilibrium is only an asymptotic phenomenon, which one must approximate by an horizon of simulation far enough in the future. Another exercise for which Dynare is well suited is to study the transition path to a new equilibrium following a permanent shock. For deterministic simulations, the numerical problem consists of solving a nonlinear system of simultaneous equations in <code>n</code> endogenous variables in <code>T</code> periods. Dynare uses a Newton-type method to solve the simultaneous equation system. Because the resulting Jacobian is in the order of <code>n</code> by <code>T</code> and hence will be very large for long simulations with many variables, Dynare makes use of the sparse matrix code .</p><h3 id="Dynare-commands"><a class="docs-heading-anchor" href="#Dynare-commands">Dynare commands</a><a id="Dynare-commands-1"></a><a class="docs-heading-anchor-permalink" href="#Dynare-commands" title="Permalink"></a></h3><h4 id="perfect_foresight_setup"><a class="docs-heading-anchor" href="#perfect_foresight_setup">perfect_foresight_setup</a><a id="perfect_foresight_setup-1"></a><a class="docs-heading-anchor-permalink" href="#perfect_foresight_setup" title="Permalink"></a></h4><p><em>Command</em>: <code>perfect\_foresight\_setup;</code></p><p><em>Command</em>: <code>perfect\_foresight\_setup (OPTIONS...);</code></p><p>Prepares a perfect foresight simulation, by extracting the information in the <code>initval</code>, <code>endval</code> and <code>shocks</code> blocks and converting them into simulation paths for exogenous and endogenous variables.</p><p>This command must always be called before running the simulation with <code>perfect\_foresight\_solver</code>.</p><h5 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h5><ul><li><code>periods = INTEGER</code></li></ul><p>Number of periods of the simulation.</p><ul><li><code>datafile = FILENAME</code></li></ul><p>Used to specify path for all endogenous and exogenous variables. Strictly equivalent to <code>initval_file</code>.</p><h5 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h5><p>The paths for the exogenous variables are stored into <code>context.results.model_resultst[1].simulations</code>.</p><p>The initial and terminal conditions for the endogenous variables and the initial guess for the path of endogenous variables are stored into <code>context.results.model_results[1].simulations</code>.</p><h4 id="perfect_foresight_solver"><a class="docs-heading-anchor" href="#perfect_foresight_solver">perfect_foresight_solver</a><a id="perfect_foresight_solver-1"></a><a class="docs-heading-anchor-permalink" href="#perfect_foresight_solver" title="Permalink"></a></h4><p><em>Command</em>: <code>perfect\_foresight\_solver ;</code></p><p><em>Command</em>: <code>perfect\_foresight\_solver (OPTIONS...);</code></p><p>Computes the perfect foresight (or deterministic) simulation of the model.</p><p>Note that <code>perfect\_foresight\_setup</code> must be called before this command, in order to setup the environment for the simulation.</p><h5 id="Options-2"><a class="docs-heading-anchor" href="#Options-2">Options</a><a class="docs-heading-anchor-permalink" href="#Options-2" title="Permalink"></a></h5><ul><li><code>maxit = INTEGER</code></li></ul><p>Determines the maximum number of iterations used in the non-linear solver. The default value of <code>maxit</code> is <code>50</code>.</p><ul><li><code>tolf = DOUBLE</code></li></ul><p>Convergence criterion for termination based on the function value. Iteration will cease when it proves impossible to improve the function value by more than <code>tolf</code>. Default: <code>1e-5</code></p><ul><li><code>tolx = DOUBLE</code></li></ul><p>Convergence criterion for termination based on the change in the function argument. Iteration will cease when the solver attempts to take a step that is smaller than <code>tolx</code>. Default: <code>1e-5</code></p><ul><li><code>noprint</code></li></ul><p>Don&#39;t print anything. Useful for loops.</p><ul><li><code>print</code></li></ul><p>Print results (opposite of <code>noprint</code>).</p><ul><li><code>lmmcp</code></li></ul><p>Solves mixed complementarity problems (the term refers to the LMMCP solver (<em>Kanzow and Petra, 2004</em>), that is used by DynareMatlab.  DynareJulia uses the PATHSovler package)</p><ul><li><code>endogenous_terminal_period</code></li></ul><p>The number of periods is not constant across Newton iterations when solving the perfect foresight model. The size of the nonlinear system of equations is reduced by removing the portion of the paths (and associated equations) for which the solution has already been identified (up to the tolerance parameter). This strategy can be interpreted as a mix of the shooting and relaxation approaches. Note that round off errors are more important with this mixed strategy (user should check the reported value of the maximum absolute error). Only available with option <code>stack_solve_algo==0</code>.</p><h4 id="Remark"><a class="docs-heading-anchor" href="#Remark">Remark</a><a id="Remark-1"></a><a class="docs-heading-anchor-permalink" href="#Remark" title="Permalink"></a></h4><pre><code class="nohighlight hljs">Be careful when employing auxiliary variables in the context of perfect
foresight computations. The same model may work for stochastic
simulations, but fail for perfect foresight simulations. The issue
arises when an equation suddenly only contains variables dated `t+1` (or
`t-1` for that matter). In this case, the derivative in the last (first)
period with respect to all variables will be 0, rendering the stacked
Jacobian singular.</code></pre><h5 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h5><p>Consider the following specification of an Euler equation with log utility:</p><pre><code class="nohighlight hljs">Lambda = beta*C(-1)/C;
Lambda(+1)*R(+1)= 1;</code></pre><p>Clearly, the derivative of the second equation with respect to all endogenous variables at time <code>t</code> is zero, causing <code>perfect_foresight_solver</code> to generally fail. This is due to the use of the Lagrange multiplier <code>Lambda</code> as an auxiliary variable. Instead, employing the identical</p><pre><code class="nohighlight hljs">beta*C/C(+1)*R(+1)= 1;</code></pre><p>will work.</p><h3 id="Julia-function"><a class="docs-heading-anchor" href="#Julia-function">Julia function</a><a id="Julia-function-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-function" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dynare.perfect_foresight!" href="#Dynare.perfect_foresight!"><code>Dynare.perfect_foresight!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">perfect_foresight!(; periods, context = context, display = true,
                   linear_solve_algo=ilu, maxit = 50, mcp = false,
                   tolf = 1e-5, tolx = 1e-5)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>periods::Int</code>: number of periods in the simulation [required]</li><li><code>context::Context=context</code>: context in which the simulation is computed</li><li><code>display::Bool=true</code>: whether to display the results</li><li><code>linear_solve_algo::LinearSolveAlgo=ilu</code>: algorithm used for the solution of the linear problem. Either <code>ilu</code> or <code>pardiso</code>. <code>ilu</code> is the sparse linear solver used by default in Julia. To use the Pardiso solver, write <code>using Pardiso</code> before running Dynare.</li><li><code>maxit::Int=50</code> maximum number of iterations</li><li><code>mcp::Bool=false</code>L whether to solve a mixed complementarity problem with occasionally binding constraints</li><li><code>tolf::Float64=1e-5</code>: tolerance for the norm of residualts</li><li><code>tolx::Float64=1e-5</code>: tolerance for the norm of the change in the result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Dynare.jl/blob/2ae3ef10772a537a3e015b3e24de4e61bf16ad5e/src/perfectforesight/perfectforesight.jl#L242-L259">source</a></section></article><h5 id="Output-2"><a class="docs-heading-anchor" href="#Output-2">Output</a><a class="docs-heading-anchor-permalink" href="#Output-2" title="Permalink"></a></h5><p>The simulated endogenous variables are available in <code>context.results.model_results[1].simulations</code>. This is a vector of <code>AxisArrayTable</code>, one for each simulations stored in <code>context</code>. Each <code>AxisArrayTable</code> contains the trajectories for endogenous and exogenous variables</p><h3 id="Solving-mixed-complementarity-problems"><a class="docs-heading-anchor" href="#Solving-mixed-complementarity-problems">Solving mixed complementarity problems</a><a id="Solving-mixed-complementarity-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-mixed-complementarity-problems" title="Permalink"></a></h3><p>requires a particular model setup as the goal is to get rid of any min/max operators and complementary slackness conditions that might introduce a singularity into the Jacobian. This is done by attaching an equation tag (see <code>model-decl</code>) with the <code>mcp</code> keyword to affected equations. The format of the <code>mcp</code> tag is</p><pre><code class="nohighlight hljs">[mcp = &#39;VARIABBLENAME OP CONSTANT&#39;]</code></pre><p>where VARIABLENAME is an endogenous variable and OP is either <code>&gt;</code> or <code>&lt;</code>. For complicated occasionally binding constraints, it may be necessary to declare a new endogenous variable.</p><p>This tag states that the equation to which the tag is attached has to hold unless the expression within the tag is binding. For instance, a ZLB on the nominal interest rate would be specified as follows in the model block:</p><pre><code class="nohighlight hljs">    model;
       ...
       [mcp = &#39;r &gt; -1.94478&#39;]
       r = rho*r(-1) + (1-rho)*(gpi*Infl+gy*YGap) + e;
       ...
    end;</code></pre><p>where  <code>r</code> is the nominal interest rate in deviation from the steady state. This construct implies that the Taylor rule is operative, unless the implied interest rate <code>r&lt;=-1.94478</code>, in which case the <code>r</code> is fixed at <code>-1.94478</code>. This is equavalant to</p><p class="math-container">\[(r_t &gt; -1.94478)\;\; \bot\;\; r_t = \rho r_{t-1} + (1-\rho) (g_\pi Infl_t+g_y YGap_t) + e_t\]</p><p>By restricting the value of <code>r</code> coming out of this equation, the <code>mcp</code> tag also avoids using <code>max(r,-1.94478)</code> for other occurrences of <code>r</code> in the rest of the model. It is important to keep in mind that, because the <code>mcp</code> tag effectively replaces a complementary slackness condition, it cannot be simply attached to any equation.</p><p>Note that in the current implementation, the content of the <code>mcp</code> equation tag is not parsed by the preprocessor. The inequalities must therefore be as simple as possible: an endogenous variable, followed by a relational operator, followed by a number (not a variable, parameter or expression).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../shocks/">« Shocks on exgogenous variables</a><a class="docs-footer-nextpage" href="../local-approxiation/">Local approximation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 23 January 2024 16:15">Tuesday 23 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
