<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Steady state · Dynare.jl</title><meta name="title" content="Steady state · Dynare.jl"/><meta property="og:title" content="Steady state · Dynare.jl"/><meta property="twitter:title" content="Steady state · Dynare.jl"/><meta name="description" content="Documentation for Dynare.jl."/><meta property="og:description" content="Documentation for Dynare.jl."/><meta property="twitter:description" content="Documentation for Dynare.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dynare.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation-and-configuration/">Installation and Configuration</a></li><li><a class="tocitem" href="../../running-dynare/">Running Dynare</a></li><li><span class="tocitem">Model File</span><ul><li><a class="tocitem" href="../syntax-elements/">Syntax elements</a></li><li><a class="tocitem" href="../variable-declarations/">Variables and parameters declaration</a></li><li><a class="tocitem" href="../model-declaration/">Model declaration</a></li><li class="is-active"><a class="tocitem" href>Steady state</a><ul class="internal"><li><a class="tocitem" href="#Providing-the-steady-state-to-Dynare"><span>Providing the steady state to Dynare</span></a></li><li><a class="tocitem" href="#Finding-the-steady-state-with-Dynare-nonlinear-solver"><span>Finding the steady state with Dynare nonlinear solver</span></a></li></ul></li><li><a class="tocitem" href="../shocks/">Shocks on exgogenous variables</a></li><li><a class="tocitem" href="../deterministic-simulations/">Deterministic simulations</a></li><li><a class="tocitem" href="../local-approxiation/">Local approximation</a></li><li><a class="tocitem" href="../filtersmoother/">State space, filtering and smoothing</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecasting/">Forecasting</a></li></ul></li><li><a class="tocitem" href="../../macroprocessor/">Macroprocessing language</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model File</a></li><li class="is-active"><a href>Steady state</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Steady state</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynareJulia/Dynare.jl/blob/main/docs/src/model-file/steady-state.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>There are three ways of computing the steady state (i.e. the static equilibrium) of a model. The first way is to provide the equations of the steady state in a <code>steady_state_model</code> block. When it is possible to derive the steady state by hand, this is the recommended way as it faster and more accurate.</p><p>The second way is to provide only a partial solution in the <code>steady_state_model</code> block and to compute the solution for the other variables numerically. Guess values for these other variables must be declared in a <code>initval</code> block. The less variables the better.</p><p>The third way is to compute the steady state value of all variables numerically. There is no <code>steady_state_model</code> block and a guess value must be declared for all variables. A guess value of 0 can be omitted, but be careful with variables appearing at the denominator of a fraction. </p><h2 id="Providing-the-steady-state-to-Dynare"><a class="docs-heading-anchor" href="#Providing-the-steady-state-to-Dynare">Providing the steady state to Dynare</a><a id="Providing-the-steady-state-to-Dynare-1"></a><a class="docs-heading-anchor-permalink" href="#Providing-the-steady-state-to-Dynare" title="Permalink"></a></h2><p>If you know how to compute the steady state for your model, you can provide a <code>steady_state_model</code> block, which is     described below in more details. The steady state file     generated by Dynare will be called <code>+FILENAME/output/julia/FILENAME_steadystate2.jl.</code></p><p>Note that this block allows for updating the parameters in each call of the function. This allows for example to calibrate a model to a labor supply of 0.2 in steady state by setting the labor disutility parameter to a corresponding value. They can also be used in estimation where some parameter may be a function of an estimated parameter and needs to be updated for every parameter draw. For example, one might want to set the capital utilization cost parameter as a function of the discount rate to ensure that capacity utilization is 1 in steady state. Treating both parameters as independent or not updating one as a function of the other would lead to wrong results. But this also means that care is required. Do not accidentally overwrite your parameters with new values as it will lead to wrong results.</p><h4 id="Steady_state_model"><a class="docs-heading-anchor" href="#Steady_state_model">Steady_state_model</a><a id="Steady_state_model-1"></a><a class="docs-heading-anchor-permalink" href="#Steady_state_model" title="Permalink"></a></h4><p><em>Block</em>: <code>steady\_state\_model ;</code></p><p>When the analytical solution of the model is known, this command can be used to help Dynare find the steady state in a more efficient and reliable way, especially during estimation where the steady state has to be recomputed for every point in the parameter space.</p><p>Each line of this block consists of a variable (either an endogenous, a temporary variable or a parameter) which is assigned an expression (which can contain parameters, exogenous at the steady state, or any endogenous or temporary variable already declared above). Each line therefore looks like:</p><pre><code class="nohighlight hljs">VARIABLE_NAME = EXPRESSION;</code></pre><p>Note that it is also possible to assign several variables at the same time, if the main function in the right hand side is a MATLAB/Octave function returning several arguments:</p><pre><code class="nohighlight hljs">[ VARIABLE_NAME, VARIABLE_NAME... ] = EXPRESSION;</code></pre><p>The <code>steady_state_model</code> block also works with deterministic models. An <code>initval</code> block and, when necessary, an <code>endval</code> block, is used to set the value of the exogenous variables. Each <code>initval</code> or <code>endval</code> block must be followed by <code>steady</code> to execute the function created by <code>steady_state_model</code> and set the initial, respectively terminal, steady state.</p><h5 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h5><pre><code class="nohighlight hljs">var m P c e W R k d n l gy_obs gp_obs y dA;
varexo e_a e_m;

parameters alp bet gam mst rho psi del;

...
// parameter calibration, (dynamic) model declaration, shock calibration...
...

steady_state_model;
dA = exp(gam);
gst = 1/dA; // A temporary variable
m = mst;

// Three other temporary variables
khst = ( (1-gst*bet*(1-del)) / (alp*gst^alp*bet) )^(1/(alp-1));
xist = ( ((khst*gst)^alp - (1-gst*(1-del))*khst)/mst )^(-1);
nust = psi*mst^2/( (1-alp)*(1-psi)*bet*gst^alp*khst^alp );

n  = xist/(nust+xist);
P  = xist + nust;
k  = khst*n;

l  = psi*mst*n/( (1-psi)*(1-n) );
c  = mst/P;
d  = l - mst + 1;
y  = k^alp*n^(1-alp)*gst^alp;
R  = mst/bet;

// You can use MATLAB functions which return several arguments
[W, e] = my_function(l, n);

gp_obs = m/dA;
gy_obs = dA;
end;

steady;</code></pre><h2 id="Finding-the-steady-state-with-Dynare-nonlinear-solver"><a class="docs-heading-anchor" href="#Finding-the-steady-state-with-Dynare-nonlinear-solver">Finding the steady state with Dynare nonlinear solver</a><a id="Finding-the-steady-state-with-Dynare-nonlinear-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-steady-state-with-Dynare-nonlinear-solver" title="Permalink"></a></h2><h3 id="Dynare-commands"><a class="docs-heading-anchor" href="#Dynare-commands">Dynare commands</a><a id="Dynare-commands-1"></a><a class="docs-heading-anchor-permalink" href="#Dynare-commands" title="Permalink"></a></h3><h4 id="initval"><a class="docs-heading-anchor" href="#initval">initval</a><a id="initval-1"></a><a class="docs-heading-anchor-permalink" href="#initval" title="Permalink"></a></h4><ul><li><em>Block</em>: <code>initval ;</code> </li></ul><p>The <code>initval</code> block provides guess values for steady state computations. </p><p>The <code>initval</code> block is terminated by <code>end;</code> and contains lines of the form:</p><pre><code class="nohighlight hljs">VARIABLE_NAME = EXPRESSION;</code></pre><h4 id="endval"><a class="docs-heading-anchor" href="#endval">endval</a><a id="endval-1"></a><a class="docs-heading-anchor-permalink" href="#endval" title="Permalink"></a></h4><ul><li><em>Block</em>: <code>endval ;</code> </li></ul><p>The <code>endval</code> block can be used in a deterministic model to provide the guess values for computing a terminal steady state that is different from the initial steady state</p><p>This block is terminated by <code>end;</code> and contains lines of the form:</p><pre><code class="nohighlight hljs">VARIABLE_NAME = EXPRESSION;</code></pre><h4 id="steady"><a class="docs-heading-anchor" href="#steady">steady</a><a id="steady-1"></a><a class="docs-heading-anchor-permalink" href="#steady" title="Permalink"></a></h4><ul><li><em>Command</em>: <code>steady ;</code> </li><li><em>Command</em>: <code>steady (OPTIONS...);</code></li></ul><p>This command computes the steady state of a model using a nonlinear Newton-type solver and displays it.</p><p>More precisely, it computes the equilibrium value of the endogenous variables for the value of the exogenous variables specified in the previous <code>initval</code> or <code>endval</code> block.</p><p><code>steady</code> uses an iterative procedure and takes as initial guess the value of the endogenous variables set in the previous <code>initval</code> or <code>endval</code> block.</p><p>For complicated models, finding good numerical initial values for the endogenous variables is the trickiest part of finding the equilibrium of that model. Often, it is better to start with a smaller model and add new variables one by one.</p><h5 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h5><ul><li><code>maxit = INTEGER</code></li></ul><p>Determines the maximum number of iterations used in the non-linear solver. The default value of <code>maxit</code> is 50.</p><ul><li><code>tolf = DOUBLE</code></li></ul><p>Convergence criterion for termination based on the function value. Iteration will cease when the residuals are smaller than <code>tolf</code>. Default: <code>eps^(1/3)</code></p><ul><li><code>tolx = DOUBLE</code></li></ul><p>Convergence criterion for termination based on the step tolerance along. Iteration will cease when the attempted step size is smaller than <code>tolx</code>. Default: <code>eps^(2/3)</code></p><ul><li><code>homotopy_steps = INTEGER</code></li></ul><p>Defines the number of steps when performing a homotopy. See <code>homotopy_mode</code> option for more details.</p><h5 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h5><p>After computation, the steady state is available in the following variables:</p><p><em>Julia variable</em>: <code>context.results.model_results[1].trends.endogenous_steady_state</code></p><p>Contains the computed steady state. Endogenous variables are ordered in the order of declaration used in the <code>var</code> command,</p><h5 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h5><pre><code class="nohighlight hljs">var c k;
varexo x;

model;
c + k - aa*x*k(-1)^alph - (1-delt)*k(-1);
c^(-gam) - (1+bet)^(-1)*(aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam);
end;

initval;
c = 1.2;
k = 12;
x = 1;
end;

steady;

endval;
c = 2;
k = 20;
x = 2;
end;

steady;
</code></pre><h4 id="Homotopy-setup"><a class="docs-heading-anchor" href="#Homotopy-setup">Homotopy setup</a><a id="Homotopy-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Homotopy-setup" title="Permalink"></a></h4><p><em>Block</em>: <code>homotopy_setup ;</code></p><p>This block is used to declare initial and final values for the parameters and exogenous variables when using a homotopy method. It is used in conjunction with the option <code>homotopy_mode</code> of the steady command.</p><p>The idea of homotopy is to subdivide the problem of finding the steady state into smaller problems. It assumes that you know how to compute the steady state for a given set of parameters, and it helps you finding the steady state for another set of parameters, by incrementally moving from one to another set of parameters.</p><p>The purpose of the <code>homotopy_setup</code> block is to declare the final (and possibly also the initial) values for the parameters or exogenous that will be changed during the homotopy. It should contain lines of the form:</p><pre><code class="nohighlight hljs">VARIABLE_NAME, EXPRESSION, EXPRESSION;</code></pre><p>This syntax specifies the initial and final values of a given parameter/exogenous.</p><p>There is an alternative syntax:</p><pre><code class="nohighlight hljs">VARIABLE_NAME, EXPRESSION;</code></pre><p>Here only the final value is specified for a given parameter/exogenous; the initial value is taken from the preceeding <code>initval</code> block.</p><p>A necessary condition for a successful homotopy is that Dynare must be able to solve the steady state for the initial parameters/exogenous without additional help (using the guess values given in the <code>initval</code> block).</p><p>If the homotopy fails, a possible solution is to increase the number of steps (given in <code>homotopy_steps</code> option of <code>steady</code>).</p><h5 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h5><p>In the following example, Dynare will first compute the steady state for the initial values (<code>gam=0.5</code> and <code>x=1</code>), and then subdivide the problem into 50 smaller problems to find the steady state for the final values (<code>gam=2</code> and <code>x=2</code>):</p><pre><code class="nohighlight hljs">var c k;
varexo x;

parameters alph gam delt bet aa;
alph=0.5;
delt=0.02;
aa=0.5;
bet=0.05;

model;
c + k - aa*x*k(-1)^alph - (1-delt)*k(-1);
c^(-gam) - (1+bet)^(-1)*(aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam);
end;

initval;
x = 1;
k = ((delt+bet)/(aa*x*alph))^(1/(alph-1));
c = aa*x*k^alph-delt*k;
end;

homotopy_setup;
gam, 0.5, 2;
x, 2;
end;

steady(homotopy_mode = 1, homotopy_steps = 50);</code></pre><h3 id="Julia-function"><a class="docs-heading-anchor" href="#Julia-function">Julia function</a><a id="Julia-function-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-function" title="Permalink"></a></h3><h4 id="steadystate!"><a class="docs-heading-anchor" href="#steadystate!">steadystate!</a><a id="steadystate!-1"></a><a class="docs-heading-anchor-permalink" href="#steadystate!" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Dynare.steadystate!" href="#Dynare.steadystate!"><code>Dynare.steadystate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate!(; context::Context=context, display::Bool = true,
        maxit::Int = 50, nocheck::Bool = false, tolf::Float64 = cbrt(eps()),
        tolx::Float64 = 0.0)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>context::Context=context</code>: context in which the simulation is computed</li><li><code>homotopy_steps::Int=0</code>: number of homotopy steps</li><li><code>display::Bool=true</code>: whether to display the results</li><li><code>maxit::Int=50</code> maximum number of iterations</li><li><code>nocheck::Bool=false</code>: don&#39;t check the steady state</li><li><code>tolf::Float64=cbrt(eps())</code>: tolerance for the norm of residualts</li><li><code>tolx::Float64=0</code>: tolerance for the norm of the change in the result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Dynare.jl/blob/43f79eec46bc4f596203dcfa14a00d9d5368fe8b/src/steady_state/SteadyState.jl#L89-L102">source</a></section></article><h3 id="Replace-some-equations-during-steady-state-computations"><a class="docs-heading-anchor" href="#Replace-some-equations-during-steady-state-computations">Replace some equations during steady state computations</a><a id="Replace-some-equations-during-steady-state-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Replace-some-equations-during-steady-state-computations" title="Permalink"></a></h3><p>When there is no steady state file, Dynare computes the steady state by solving the static model, i.e. the model from the <code>.mod</code> file from which leads and lags have been removed.</p><p>In some specific cases, one may want to have more control over the way this static model is created. Dynare therefore offers the possibility to explicitly give the form of equations that should be in the static model.</p><p>More precisely, if an equation is prepended by a <code>[static]</code> tag, then it will appear in the static model used for steady state computation, but that equation will not be used for other computations. For every equation tagged in this way, you must tag another equation with <code>[dynamic]</code>: that equation will not be used for steady state computation, but will be used for other computations.</p><p>This functionality can be useful on models with a unit root, where there is an infinity of steady states. An equation (tagged <code>[dynamic]</code>) would give the law of motion of the nonstationary variable (like a random walk). To pin down one specific steady state, an equation tagged <code>[static]</code> would affect a constant value to the nonstationary variable. Another situation where the <code>[static]</code> tag can be useful is when one has only a partial closed form solution for the steady state.</p><h5 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h5><p>This is a trivial example with two endogenous variables. The second equation takes a different form in the static model:</p><pre><code class="nohighlight hljs">var c k;
varexo x;
...
model;
c + k - aa*x*k(-1)^alph - (1-delt)*k(-1);
[dynamic] c^(-gam) - (1+bet)^(-1)*(aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam);
[static] k = ((delt+bet)/(x*aa*alph))^(1/(alph-1));
end;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model-declaration/">« Model declaration</a><a class="docs-footer-nextpage" href="../shocks/">Shocks on exgogenous variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 29 December 2023 15:30">Friday 29 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
